{"version":3,"file":"Validate.js","sourceRoot":"","sources":["../../../../src/decorator/common/Validate.ts"],"names":[],"mappings":";;;AAEA,0EAAuE;AACvE,oEAAoE;AACpE,sEAAmE;AACnE,0EAAuE;AAEvE;;GAEG;AACH,SAAgB,mBAAmB,CAAC,OAA4C;IAC9E,OAAO,UAAU,MAAgB;QAC/B,MAAM,OAAO,GAAG,OAAO,IAAI,OAAO,CAAC,KAAK,CAAC;QACzC,IAAI,IAAI,GAAG,OAAO,IAAI,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC;QACvD,IAAI,CAAC,IAAI,EAAE;YACT,IAAI,GAAI,MAAc,CAAC,IAAI,CAAC;YAC5B,IAAI,CAAC,IAAI;gBACP,oCAAoC;gBACpC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,GAAG,GAAI,CAAY,CAAC,WAAW,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;SACtG;QACD,MAAM,QAAQ,GAAG,IAAI,uCAAkB,CAAC,MAAM,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;QAC/D,oCAAkB,EAAE,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC;IACvD,CAAC,CAAC;AACJ,CAAC;AAbD,kDAaC;AAYD,SAAgB,QAAQ,CACtB,eAAyB,EACzB,8BAA0D,EAC1D,sBAA0C;IAE1C,OAAO,UAAU,MAAc,EAAE,YAAoB;QACnD,MAAM,IAAI,GAA2B;YACnC,IAAI,EAAE,iCAAe,CAAC,iBAAiB;YACvC,MAAM,EAAE,MAAM,CAAC,WAAW;YAC1B,YAAY,EAAE,YAAY;YAC1B,aAAa,EAAE,eAAe;YAC9B,WAAW,EAAE,8BAA8B,YAAY,KAAK,CAAC,CAAC,CAAC,8BAA8B,CAAC,CAAC,CAAC,SAAS;YACzG,iBAAiB,EAAE,CAAC,CAAC,8BAA8B,YAAY,KAAK,CAAC;gBACnE,CAAC,CAAC,8BAA8B;gBAChC,CAAC,CAAC,sBAAsB;SAC3B,CAAC;QACF,oCAAkB,EAAE,CAAC,qBAAqB,CAAC,IAAI,uCAAkB,CAAC,IAAI,CAAC,CAAC,CAAC;IAC3E,CAAC,CAAC;AACJ,CAAC;AAlBD,4BAkBC","sourcesContent":["import { ValidationOptions } from '../ValidationOptions';\r\nimport { ValidationMetadataArgs } from '../../metadata/ValidationMetadataArgs';\r\nimport { ValidationMetadata } from '../../metadata/ValidationMetadata';\r\nimport { getMetadataStorage } from '../../metadata/MetadataStorage';\r\nimport { ValidationTypes } from '../../validation/ValidationTypes';\r\nimport { ConstraintMetadata } from '../../metadata/ConstraintMetadata';\r\n\r\n/**\r\n * Registers custom validator class.\r\n */\r\nexport function ValidatorConstraint(options?: { name?: string; async?: boolean }) {\r\n  return function (target: Function): void {\r\n    const isAsync = options && options.async;\r\n    let name = options && options.name ? options.name : '';\r\n    if (!name) {\r\n      name = (target as any).name;\r\n      if (!name)\r\n        // generate name if it was not given\r\n        name = name.replace(/\\.?([A-Z]+)/g, (x, y) => '_' + (y as string).toLowerCase()).replace(/^_/, '');\r\n    }\r\n    const metadata = new ConstraintMetadata(target, name, isAsync);\r\n    getMetadataStorage().addConstraintMetadata(metadata);\r\n  };\r\n}\r\n\r\n/**\r\n * Performs validation based on the given custom validation class.\r\n * Validation class must be decorated with ValidatorConstraint decorator.\r\n */\r\nexport function Validate(constraintClass: Function, validationOptions?: ValidationOptions): PropertyDecorator;\r\nexport function Validate(\r\n  constraintClass: Function,\r\n  constraints?: any[],\r\n  validationOptions?: ValidationOptions\r\n): PropertyDecorator;\r\nexport function Validate(\r\n  constraintClass: Function,\r\n  constraintsOrValidationOptions?: any[] | ValidationOptions,\r\n  maybeValidationOptions?: ValidationOptions\r\n): PropertyDecorator {\r\n  return function (object: object, propertyName: string): void {\r\n    const args: ValidationMetadataArgs = {\r\n      type: ValidationTypes.CUSTOM_VALIDATION,\r\n      target: object.constructor,\r\n      propertyName: propertyName,\r\n      constraintCls: constraintClass,\r\n      constraints: constraintsOrValidationOptions instanceof Array ? constraintsOrValidationOptions : undefined,\r\n      validationOptions: !(constraintsOrValidationOptions instanceof Array)\r\n        ? constraintsOrValidationOptions\r\n        : maybeValidationOptions,\r\n    };\r\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\r\n  };\r\n}\r\n"]}