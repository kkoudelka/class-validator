{"version":3,"file":"Matches.js","sourceRoot":"","sources":["../../../../src/decorator/string/Matches.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,YAAY,EAAE,UAAU,EAAE,MAAM,sBAAsB,CAAC;AAChE,OAAO,gBAAgB,MAAM,uBAAuB,CAAC;AAErD,MAAM,CAAC,IAAM,OAAO,GAAG,SAAS,CAAC;AAQjC,MAAM,UAAU,OAAO,CAAC,KAAa,EAAE,OAAwB,EAAE,SAAkB;IACjF,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,gBAAgB,CAAC,KAAK,EAAG,OAA0B,EAAE,SAAS,CAAC,CAAC;AACtG,CAAC;AAQD,MAAM,UAAU,OAAO,CACrB,OAAwB,EACxB,4BAAyD,EACzD,iBAAqC;IAErC,IAAI,SAAiB,CAAC;IACtB,IAAI,4BAA4B,IAAI,4BAA4B,YAAY,MAAM,IAAI,CAAC,iBAAiB,EAAE;QACxG,iBAAiB,GAAG,4BAA4B,CAAC;KAClD;SAAM;QACL,SAAS,GAAG,4BAAsC,CAAC;KACpD;IAED,OAAO,UAAU,CACf;QACE,IAAI,EAAE,OAAO;QACb,WAAW,EAAE,CAAC,OAAO,EAAE,SAAS,CAAC;QACjC,SAAS,EAAE;YACT,QAAQ,EAAE,UAAC,KAAK,EAAE,IAAI,IAAc,OAAA,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,EAAxD,CAAwD;YAC5F,cAAc,EAAE,YAAY,CAC1B,UAAC,UAAU,EAAE,IAAI,IAAK,OAAA,UAAU,GAAG,sDAAsD,EAAnE,CAAmE,EACzF,iBAAiB,CAClB;SACF;KACF,EACD,iBAAiB,CAClB,CAAC;AACJ,CAAC","sourcesContent":["import { ValidationOptions } from '../ValidationOptions';\r\nimport { buildMessage, ValidateBy } from '../common/ValidateBy';\r\nimport matchesValidator from 'validator/lib/matches';\r\n\r\nexport const MATCHES = 'matches';\r\n\r\n/**\r\n * Checks if string matches the pattern. Either matches('foo', /foo/i).\r\n * If given value is not a string, then it returns false.\r\n */\r\nexport function matches(value: string, pattern: RegExp): boolean;\r\nexport function matches(value: string, pattern: string, modifiers: string): boolean;\r\nexport function matches(value: string, pattern: RegExp | string, modifiers?: string): boolean {\r\n  return typeof value === 'string' && matchesValidator(value, (pattern as unknown) as any, modifiers);\r\n}\r\n\r\n/**\r\n * Checks if string matches the pattern. Either matches('foo', /foo/i)\r\n * If given value is not a string, then it returns false.\r\n */\r\nexport function Matches(pattern: RegExp, validationOptions?: ValidationOptions): PropertyDecorator;\r\nexport function Matches(pattern: string, modifiers?: string, validationOptions?: ValidationOptions): PropertyDecorator;\r\nexport function Matches(\r\n  pattern: RegExp | string,\r\n  modifiersOrAnnotationOptions?: string | ValidationOptions,\r\n  validationOptions?: ValidationOptions\r\n): PropertyDecorator {\r\n  let modifiers: string;\r\n  if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {\r\n    validationOptions = modifiersOrAnnotationOptions;\r\n  } else {\r\n    modifiers = modifiersOrAnnotationOptions as string;\r\n  }\r\n\r\n  return ValidateBy(\r\n    {\r\n      name: MATCHES,\r\n      constraints: [pattern, modifiers],\r\n      validator: {\r\n        validate: (value, args): boolean => matches(value, args.constraints[0], args.constraints[1]),\r\n        defaultMessage: buildMessage(\r\n          (eachPrefix, args) => eachPrefix + '$property must match $constraint1 regular expression',\r\n          validationOptions\r\n        ),\r\n      },\r\n    },\r\n    validationOptions\r\n  );\r\n}\r\n"]}