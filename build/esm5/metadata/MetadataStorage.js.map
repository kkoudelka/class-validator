{"version":3,"file":"MetadataStorage.js","sourceRoot":"","sources":["../../../src/metadata/MetadataStorage.ts"],"names":[],"mappings":"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","sourcesContent":["import { ValidationMetadata } from './ValidationMetadata';\r\nimport { ConstraintMetadata } from './ConstraintMetadata';\r\nimport { ValidationSchema } from '../validation-schema/ValidationSchema';\r\nimport { ValidationSchemaToMetadataTransformer } from '../validation-schema/ValidationSchemaToMetadataTransformer';\r\nimport { getGlobal } from '../utils';\r\n\r\n/**\r\n * Storage all metadatas.\r\n */\r\nexport class MetadataStorage {\r\n  // -------------------------------------------------------------------------\r\n  // Private properties\r\n  // -------------------------------------------------------------------------\r\n\r\n  private validationMetadatas: ValidationMetadata[] = [];\r\n  private constraintMetadatas: ConstraintMetadata[] = [];\r\n\r\n  get hasValidationMetaData(): boolean {\r\n    return !!this.validationMetadatas.length;\r\n  }\r\n\r\n  // -------------------------------------------------------------------------\r\n  // Public Methods\r\n  // -------------------------------------------------------------------------\r\n\r\n  /**\r\n   * Adds a new validation metadata.\r\n   */\r\n  addValidationSchema(schema: ValidationSchema): void {\r\n    const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\r\n    validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\r\n  }\r\n\r\n  /**\r\n   * Adds a new validation metadata.\r\n   */\r\n  addValidationMetadata(metadata: ValidationMetadata): void {\r\n    this.validationMetadatas.push(metadata);\r\n  }\r\n\r\n  /**\r\n   * Adds a new constraint metadata.\r\n   */\r\n  addConstraintMetadata(metadata: ConstraintMetadata): void {\r\n    this.constraintMetadatas.push(metadata);\r\n  }\r\n\r\n  /**\r\n   * Groups metadata by their property names.\r\n   */\r\n  groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\r\n    const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\r\n    metadata.forEach(metadata => {\r\n      if (!grouped[metadata.propertyName]) grouped[metadata.propertyName] = [];\r\n      grouped[metadata.propertyName].push(metadata);\r\n    });\r\n    return grouped;\r\n  }\r\n\r\n  /**\r\n   * Gets all validation metadatas for the given object with the given groups.\r\n   */\r\n  getTargetValidationMetadatas(\r\n    targetConstructor: Function,\r\n    targetSchema: string,\r\n    always: boolean,\r\n    strictGroups: boolean,\r\n    groups?: string[]\r\n  ): ValidationMetadata[] {\r\n    const includeMetadataBecauseOfAlwaysOption = (metadata: ValidationMetadata): boolean => {\r\n      // `metadata.always` overrides global default.\r\n      if (typeof metadata.always !== 'undefined') return metadata.always;\r\n\r\n      // `metadata.groups` overrides global default.\r\n      if (metadata.groups && metadata.groups.length) return false;\r\n\r\n      // Use global default.\r\n      return always;\r\n    };\r\n\r\n    const excludeMetadataBecauseOfStrictGroupsOption = (metadata: ValidationMetadata): boolean => {\r\n      if (strictGroups) {\r\n        // Validation is not using groups.\r\n        if (!groups || !groups.length) {\r\n          // `metadata.groups` has at least one group.\r\n          if (metadata.groups && metadata.groups.length) return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    };\r\n\r\n    // get directly related to a target metadatas\r\n    const originalMetadatas = this.validationMetadatas.filter(metadata => {\r\n      if (metadata.target !== targetConstructor && metadata.target !== targetSchema) return false;\r\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\r\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\r\n      if (groups && groups.length > 0)\r\n        return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\r\n\r\n      return true;\r\n    });\r\n\r\n    // get metadatas for inherited classes\r\n    const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\r\n      // if target is a string it's means we validate against a schema, and there is no inheritance support for schemas\r\n      if (typeof metadata.target === 'string') return false;\r\n      if (metadata.target === targetConstructor) return false;\r\n      if (metadata.target instanceof Function && !(targetConstructor.prototype instanceof metadata.target))\r\n        return false;\r\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\r\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\r\n      if (groups && groups.length > 0)\r\n        return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\r\n\r\n      return true;\r\n    });\r\n\r\n    // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\r\n    const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\r\n      return !originalMetadatas.find(originalMetadata => {\r\n        return (\r\n          originalMetadata.propertyName === inheritedMetadata.propertyName &&\r\n          originalMetadata.type === inheritedMetadata.type\r\n        );\r\n      });\r\n    });\r\n\r\n    return originalMetadatas.concat(uniqueInheritedMetadatas);\r\n  }\r\n\r\n  /**\r\n   * Gets all validator constraints for the given object.\r\n   */\r\n  getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\r\n    return this.constraintMetadatas.filter(metadata => metadata.target === target);\r\n  }\r\n}\r\n\r\n/**\r\n * Gets metadata storage.\r\n * Metadata storage follows the best practices and stores metadata in a global variable.\r\n */\r\nexport function getMetadataStorage(): MetadataStorage {\r\n  const global = getGlobal();\r\n\r\n  if (!global.classValidatorMetadataStorage) {\r\n    global.classValidatorMetadataStorage = new MetadataStorage();\r\n  }\r\n\r\n  return global.classValidatorMetadataStorage;\r\n}\r\n"]}